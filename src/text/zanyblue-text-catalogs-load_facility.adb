--
--  ZanyBlue, an Ada library and framework for finite element analysis.
--  Copyright (C) 2009  Michael Rohan <michael@zanyblue.com>
--
--  This program is free software; you can redistribute it and/or modify
--  it under the terms of the GNU General Public License as published by
--  the Free Software Foundation; either version 2 of the License, or
--  (at your option) any later version.
--
--  This program is distributed in the hope that it will be useful,
--  but WITHOUT ANY WARRANTY; without even the implied warranty of
--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--  GNU General Public License for more details.
--
--  You should have received a copy of the GNU General Public License
--  along with this program; if not, write to the Free Software
--  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
--

pragma License (Modified_GPL);

with Ada.Directories;
with Ada.Strings.Unbounded;

-------------------
-- Load_Facility --
-------------------

separate (ZanyBlue.Text.Catalogs)
procedure Load_Facility (Facility    : Wide_String;
                         Source_Name : Wide_String;
                         N_Locales   : out Natural;
                         N_Messages  : out Natural;
                         Handler     : in out Catalog_Handler_Type'Class;
                         Directory   : Wide_String := ".";
                         Extension   : Wide_String := Default_Extension;
                         Locales     : Locale_Set := Locale_Sets.Empty_Set) is

   use Ada.Directories;
   use Ada.Strings.Unbounded;

   type Property_File is
      record
         File_Name : Unbounded_String;
         Locale    : Locale_Type;
      end record;
   --  The loading of a facility requires scanning directory for propreties
   --  files associated with the facility.  The file paths and associated
   --  locales are stored in a list by the scanning routine and later loaded
   --  by the loading routine.  The Property_File stores an instance of
   --  such a file.

   function "<" (Left, Right : Property_File) return Boolean;
   --  Need an ordering function to support sorting.  The list of properties
   --  files is sorted to ensure a given set of files is always processed in
   --  the same order on different platforms (the order of files generated by
   --  directory scanning is not defined.  The file are ordered by locale.

   package Property_File_Vectors is
      new Indefinite_Vectors (Index_Type      => Positive,
                              Element_Type    => Property_File);
   subtype Property_File_List is Property_File_Vectors.Vector;
   --  The package implementing the list of properties files.

   package Sorter is new Property_File_Vectors.Generic_Sorting;
   --  The package implementing the sorting routine for list of files.

   procedure Scan_Properties (Result : in out Property_File_List);
   --  Scan the source directory for properties files matching the facility
   --  name.  The file found are added to the Result list.

   procedure Load_Properties (List : Property_File_List);
   --  Once the list of files has been generated, the properties are loaded
   --  using the the Load_Properties routine.

   ---------
   -- "<" --
   ---------

   function "<" (Left, Right : Property_File) return Boolean is
   begin
      if Left.Locale = Right.Locale then
         return Left.File_Name < Right.File_Name;
      else
         return Locale_Name (Left.Locale) < Locale_Name (Right.Locale);
      end if;
   end "<";

   ---------------------
   -- Load_Properties --
   ---------------------

   procedure Load_Properties (List : Property_File_List) is

      procedure Load_Source (E : Property_File);
      --  Load an individual properties file.

      -----------------
      -- Load_Source --
      -----------------

      procedure Load_Source (E : Property_File) is
      begin
         if Locales.Length = 0 or Locales.Contains (E.Locale) then
            Load_File (From_UTF8 (To_String (E.File_Name)), Facility,
                       E.Locale, Handler);
            N_Locales := N_Locales + 1;
         end if;
      exception
      when Name_Error =>
         null;
      end Load_Source;

   begin
      N_Locales := 0;
      Handler.Reset_N_Messages;
      for I in 1 .. Integer (List.Length) loop
         List.Query_Element (I, Load_Source'Access);
      end loop;
      N_Messages := Handler.Get_N_Messages;
   end Load_Properties;

   ---------------------
   -- Scan_Properties --
   ---------------------

   procedure Scan_Properties (Result : in out Property_File_List) is

      function File_Locale (File_Name      : String;
                            Simple_Name    : String) return Locale_Type;
      --  Determine the locale defined by the file name, e.g.,
      --  "xmpl_fr.properties" => "fr"

      -----------------
      -- File_Locale --
      -----------------

      function File_Locale (File_Name      : String;
                            Simple_Name    : String) return Locale_Type is

         B_Name : constant String := Base_Name (File_Name);
         A      : constant Positive := B_Name'First + Simple_Name'Length + 1;
         B      : constant Positive := B_Name'Last;
         L_Name : constant Wide_String := To_Wide_String (B_Name (A .. B));
         Locale : constant Locale_Type := Make_Locale (L_Name);

      begin
         return Locale;
      end File_Locale;

      Base_File_Name   : constant String := Compose (To_UTF8 (Directory),
                                                     To_UTF8 (Source_Name),
                                                     To_UTF8 (Extension));
      Base_Full_Name   : constant String := Full_Name (Base_File_Name);
      Base_Directory   : constant String
                               := Containing_Directory (Base_Full_Name);
      Simple_File_Name : constant String
                               := Base_Name (Simple_Name (Base_Full_Name));
      Search_Pattern   : constant String := To_UTF8 (Source_Name)
                                          & "_*."
                                          & To_UTF8 (Extension);
      File_Search : Search_Type;
      Item : Directory_Entry_Type;
      Filter : constant Filter_Type := (Ordinary_File => True,
                                        others => False);
   begin
      Result.Append (Property_File'(
                        File_Name => To_Unbounded_String (Base_File_Name),
                        Locale    => <>));
      Start_Search (File_Search, Base_Directory, Search_Pattern, Filter);
      while More_Entries (File_Search) loop
         Get_Next_Entry (File_Search, Item);
         Result.Append (Property_File'(
                           File_Name => To_Unbounded_String (Full_Name (Item)),
                           Locale    => File_Locale (Full_Name (Item),
                                                     Simple_File_Name)));
      end loop;
      End_Search (File_Search);
   end Scan_Properties;

   Property_Files : Property_File_List;

begin
   Scan_Properties (Property_Files);
   Sorter.Sort (Property_Files);
   Load_Properties (Property_Files);
end Load_Facility;
