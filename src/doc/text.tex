%
%  ZanyBlue, an Ada library and framework for finite element analysis.
%  Copyright Â© 2009, 2010  Michael Rohan <michael@zanyblue.com>
%
%  This program is free software; you can redistribute it and/or modify
%  it under the terms of the GNU General Public License as published by
%  the Free Software Foundation; either version 2 of the License, or
%  (at your option) any later version.
%
%  This program is distributed in the hope that it will be useful,
%  but WITHOUT ANY WARRANTY; without even the implied warranty of
%  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%  GNU General Public License for more details.
%
%  You should have received a copy of the GNU General Public License
%  along with this program; if not, write to the Free Software
%  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
%

\chapter{The Text Package}

The intent of the \texttt{Text} package is to allow the separate
definition of the text messages displayed by an application into a
\texttt{.properties} file.  Messages are reference in the source code
by a key value (a simple string) within a group of related messages
for a facility.  The message strings include Java style message argument
place holders: argument number (zero-based) along with optional type specific
formatting information enclosed in chain brackets.

The divorce of the message text from the source code allows the easy
localization of application messages.  The source language \texttt{.properties}
file is delivered to translation vendors who return localized
\texttt{.properties} files.  E.g., for an application \texttt{myapp}, with
application messages defined in the file
\begin{verbatim}
    myapp.properties
\end{verbatim}
the localized French and Japanese files would be
\begin{verbatim}
    myapp_fr.properties
    myapp_ja.properties
\end{verbatim}

The \texttt{Text} package supports message text searching among a set of
localized \texttt{.properties} files with fallback to available messages.
For example, if the above application, \texttt{myapp}, is run in a Canadian
French environment (\texttt{ZB\_LANG=fr\_CA}), each message is localized by
trying to locate the message in the files, in order,
\begin{verbatim}
    myapp_fr_CA.properties
    myapp_fr.properties
    myapp.properties
\end{verbatim}
If no French localized message is available, the source development language
message text is used, i.e., the properties file which does not include a
language code.  Frequently this English in the United States.

The localization of a message cannot, in general, occur using just the
text 'snippets' surrounding values generated by an application, e.g., the
externally visible message
\begin{verbatim}
    There are 2 moons orbiting "Mars".
\end{verbatim}
could be divided into the `snippets'
\begin{itemize}
\item ``\texttt{There are}''
\item ``\texttt{moons orbiting}''
\item ``\texttt{.}''
\end{itemize}
which a translation vendor needs to localize independently, a rather difficult
task to do for general text `snippets'.  A more reasonable proposition is
to supply translation vendors complete sentences with application supplied
arguments embedded.  Using the Java style, the above message would be defined
in an external properties file as
\begin{verbatim}
    moons=There are {0} moons orbiting "{1}".
\end{verbatim}
where ``\texttt{moons}'' is the message key and the application message
arguments are referenced within chain brackets.  In the example here, argument
0 would be the integer \texttt{2} and argument 1 would be the string
``\texttt{Mars}''.

\section{Simple Example}

As an introduction to the \texttt{Text} package, a simple example, which
continues the example based on the number of moons orbiting the various
planets, is developed.

The task is to ask the user for a planet name and print the number of currently
known moons for the planet.  Here is the source for this simple example
the source is available in the directory \texttt{examples/text/moons}).
\begin{xmpl}
\begin{verbatim}
with Ada.Wide_Text_IO;
with Moons_Messages;
with ZanyBlue.Text.Formatting;
with ZanyBlue.Text.Generic_Enumerations;

procedure Moons is

   type Planet_Names is (Mercury, Venus, Earth, Mars,
                         Jupiter, Saturn, Uranus, Neptune);
   package Planet_Name_Formatting is
      new ZanyBlue.Text.Generic_Enumerations (Planet_Names);
   package Planet_Name_IO is
      new Ada.Wide_Text_IO.Enumeration_IO (Planet_Names);

   use Ada.Wide_Text_IO;
   use Planet_Name_Formatting;
   use ZanyBlue.Text.Formatting;

   Moons  : array (Planet_Names) of Natural := (
                   Earth => 1, Mars => 2, Jupiter => 63,
                   Saturn => 62, Uranus => 27, Neptune => 13,
                   others => 0);
   Planet : Planet_Names;

begin
   loop
      Print ("moons", "0001");
      Planet_Name_IO.Get (Planet);
      if Moons (Planet) /= 1 then
         Print_Line ("moons", "0002", +Moons (Planet),
                                      +Planet);
      else
         Print_Line ("moons", "0003", +Planet);
      end if;
   end loop;
exception
when End_Error | Data_Error =>
    New_Line;
    Print_Line ("moons", "0004");
end Moons;
\end{verbatim}
\end{xmpl}

Here the messages for the application are referred to by message id or
key, e.g., "\texttt{0001}" for the facility "\texttt{moons}".  The text associated
with these message keys are externalized to a \texttt{.properties} file.  For
this example, the English properties file, "\texttt{moons.properties}" contains
\begin{xmpl}
\begin{verbatim}
   0001=Please enter a planet: 
   0002=There are {0} known moons orbiting "{1}".
   0003=There is 1 known moon orbiting "{0}".
   0004=OK, goodbye.
\end{verbatim}
\end{xmpl}

A German translation of this properties, "\texttt{moons\_de.properties}" file would
be (via Google Translate)
\begin{small}
\begin{verbatim}
   0001=Bitte geben Sie einen Planeten: 
   0002=Es gibt {0} bekannte Monde umkreisen "{1}".
   0003=Es gibt 1 bekannt Mond umkreisen "{0}".
   0004=OK, auf Wiedersehen.
\end{verbatim}
\end{small}

The properites and application are tied together by "compiling" the properties
files into an Ada package and simply with'ing the compiled package in the
application (normally in the unit containing the main procedure).  In this
example, the generated package referenced in the source above is
\texttt{Moons\_Messages} which is created using the \texttt{zbmcompile} ZanyBlue
utility:
\begin{xmpl}
\begin{verbatim}
   $ zbmcompile -i -v Moons_Messages moons
   This is ZBMCompile, Version 0.1.0 ALPHA (r1627) at 5:52 PM on 11/19/10
   Copyright (c) 2009-2010, Michael Rohan.  All rights reserved
   Loaded 16 messages for the facility "moons" (4 locales)
   Loaded 1 facilities, 4 keys, 4 locales and 16 messages
   Wrote the spec "Moons_Messages" to the file "moons_messages.ads"
   Wrote the body "Moons_Messages" to the file "moons_messages.adb"
   ZBMCompile completed at 5:52 PM on 11/19/10, elapsed time 0:00:00.263
\end{verbatim}
\end{xmpl}

This generates an Ada specification containing the name of the facility,
``moons'' in this case, and the definition of a single initialization routine.
The body file contains the message data, the initialization routine which
adds the message data to the shared message pool.  Since the \texttt{-i}
command line option was used, the generated package body includes call
to the initialization routine allowing the message data to be included
in the application via a simple \texttt{with} of the package, i.e., no
explicit call to the initialization routine is needed.

%--------------------------------------------------------------------------
\section{Locale Definition}

The ZanyBlue Text routines allow the explicit definition of the locale for a
particular function/procedure call but this normally not needed allowing the
locale to default to the currently defined locale.  The default locale is
taken from the process environment via the variable \texttt{ZB\_LANG}, and,
if that is not defined, uses
\begin{enumerate}
\item On Unix systems, the value of the environment variable \texttt{LANG}.
\item On Windows systems, the translation of the user's default LCID value
      to a standard locale name (language, script and territory triple).
\end{enumerate}
The default locale used can be adjusted at run time using the
\texttt{Set\_Locale} routine, e.g., to explicitly set the locale to Canadian
French, the call would be
\begin{xmpl}
\begin{verbatim}
   Set_Locale (Name => "fr_CA");
\end{verbatim}
\end{xmpl}

The Makefiles for the example applications generally include ``\texttt{run}''
targets which run the applications in the default locale.  They also include
rules to run application in other locales by tagging on the locale name to
``\texttt{run\_}'', e.g., to run the \texttt{ojdbc} example in a Greek locale,
the command would be
\begin{xmpl}
\begin{verbatim}
   $ make run_el
\end{verbatim}
\end{xmpl}

%--------------------------------------------------------------------------
\section{Locale Resolution}

The message selected for a particular facility and key depends on the locale.
If there no message associated with the given key, the parent locale is tried
and it's parent and so on until a message is found or the root locale is
reached.

ZanyBlue implements a general locale parenting algorithm which does the
obvious for simple language and territory locales.  E.g., the parent of
the locale "\texttt{de\_DE}" is "\texttt{de}" which, in turn, has as it's
parent the root locale.  A similar algorithm is used for simple language
and script locales, e.g., the parent of the locale "\texttt{en\_Latn}" is
"\texttt{en}", which, again, has as it's parent the root locale.

The locale parenting algorithm for full language, script and territory
locales will have an ancestor tree of language and script, then language
and terrority, then language and finally the root locale.  For example,
the sequence of locales tried for the locale "\texttt{fr\_Latn\_FR}" is
\begin{enumerate}
\item \texttt{fr\_Latn\_FR}
\item \texttt{fr\_Latn}
\item \texttt{fr\_FR}
\item \texttt{fr}
\item Root Locale
\end{enumerate}

%--------------------------------------------------------------------------
\section{Built-in Localizations}

Localization for dates, times, language names, script names and territory
names are compiled into the ZanyBlue Text library based on the Unicode.org
Common Locale Date Repository (CLDR).  For details on date and time formatting
see the section on \texttt{Ada.Calendar.Time} argument types later.

The localized name associated with standard language, script and territory
abbreviations are available via the various routines defined in the package
\texttt{ZanyBlue.Text.CLDR}.

The library is currently implemented to use the CLDR data to determine the
zero character when printing numbers (integers).  This is normally the
standard ASCII "0", however, some languages, e.g., Arabic, have there own
numeric characters.  In Arabic locale, \texttt{ZanyBlue.Text} will generate
numeric (integer) output using Arabic numerals.  Whether this is a feature
or an error is unclear at this time.

For this release, the built-in languages are
\begin{center}
\begin{tabular}{|l|l|}\hline
Code & Language\\\hline
\texttt{ar} & Arabic\\
\texttt{cs} & Czech\\
\texttt{da} & Danish\\
\texttt{de} & German\\
\texttt{el} & Greek\\
\texttt{en} & English (normally the root locale)\\
\texttt{es} & Spanish\\
\texttt{fi} & Finnish\\
\texttt{fr} & French\\
\texttt{he} & Hebrew\\
\texttt{hu} & Hungarian\\
\texttt{it} & Italian\\
\texttt{iw} & Hebrew (deprecated)\\
\texttt{ja} & Japanese\\
\texttt{ko} & Korean\\
\texttt{nb} & Norwegian Bokm\o{a}l\\
\texttt{nl} & Dutch\\
\texttt{no} & Norwegian\\
\texttt{pl} & Polish\\
\texttt{pt} & Portuguese\\
\texttt{ro} & Romanian\\
\texttt{ru} & Russian\\
\texttt{sk} & Slovak\\
\texttt{sv} & Swedish\\
\texttt{th} & Thai\\
\texttt{tr} & Turkish\\
\texttt{zh} & Chinese (Simplified)\\
\texttt{zh\_Hant} & Chinese (Traditional)\\\hline
\end{tabular}
\end{center}

%--------------------------------------------------------------------------
\section{Message Formatting}

From the simple ``moons'' example above, it can be seen that simply
externalizing just the text used to in an application without the argument
formatting is not enough to fully support localization.  The messages
externalized must be the complete messages with embedded placeholders for
the arguments substituted at runtime.

The ZanyBlue Text library currently uses a mixture of Java and Python styles
for embedded arguments.  Arguments to the message are referenced by index
(zero based) and enclosed in chain brackets.

From the ``moons'' example, message ``\texttt{0002}'' has the definition
\begin{xmpl}
\begin{verbatim}
   0002=There are {0} known moons orbiting "{1}".
\end{verbatim}
\end{xmpl}

Here the first argument (argument 0) is an integer and second argument (argument
1) is an enumeration value giving the planet name.

At runtime, arguments to messages are ``boxed'' into a tagged type with
dispatching methods that perform the formatting to strings.  Each type has
it's own implementation (see ``Provided Argument Types'' later).  Boxing
occurs by creating a boxed object for the argument value and passed to the
various message formatting or printing routines.  The boxing function has
a standard ``\texttt{Create}'' name and a renaming ``\texttt{+}'' making
formatting or printing calls look more natural.  For example, the message
text above could be formatted with an integer argument, 2, and a string
argument, "Mars", as
\begin{xmpl}
\begin{verbatim}
    Message := Format ("moons", "0002", +2, +String'("Mars"));
\end{verbatim}
\end{xmpl}
The explicit type coersion to \texttt{String} is required as both standard
\texttt{String} and \texttt{Wide\_String} are supported.

The formatting or printing routines accept upto 5 optional boxed arguments.
The implementation gathers the supplied boxed arguments into an argument
list and then calls the underlying formatting routine with the argument
list.  For arguments beyond 5, the underlying argument list type must be
used and the arguments must be explicitly appended, e.g., the above
example could be rephrased in terms of the lower level argument list based
formatting routine as
\begin{xmpl}
\begin{verbatim}
   declare
      Arguments : Argument_List;
   begin
      Arguments.Append (1);
      Arguments.Append (String'("Mars"));
      Messages := Format ("moons", "0002", Arguments);
   end;
\end{verbatim}
\end{xmpl}


\subsection{Python Formatting Syntax}

Additional formatting information can be included in the argument reference
via an optional format string after the index value, separated by either a
comma or a colon.  The format syntax is based on the syntax defined for Python
format strings in most cases (see the Argument Types section for details
on types that use additional, non-Python style formatting, e.g, dates and
time).

The Python description of this syntax is:

``Format specifications'' are used within replacement fields
contained within a format string to define how individual values
are presented (see Format String Syntax.) They can also be passed
directly to the builtin format() function. Each formattable type
may define how the format specification is to be interpreted.

Most built-in types implement the following options for format
specifications, although some of the formatting options are only
supported by the numeric types.

A general convention is that an empty format string ("") produces
the same result as if you had called \texttt{str()} on the value.

The general form of a standard format specifier is:
\begin{xmpl}
\begin{verbatim}
      format_spec ::=  [[fill]align][sign][#][0][width][.precision][type]
      fill        ::=  <a character other than '}'>
      align       ::=  "<" | ">" | "=" | "^"
      sign        ::=  "+" | "-" | " "
      width       ::=  integer
      precision   ::=  integer
      type        ::=  "b" | "c" | "d" | "e" | "E" | "f" | "F"
                     | "g" | "G" | "n" | "o" | "x" | "X" | "%"
\end{verbatim}
\end{xmpl}

The fill character can be any character other than '\}' (which
signifies the end of the field). The presence of a fill character is
signaled by the next character, which must be one of the alignment
options. If the second character of format\_spec is not a valid
alignment option, then it is assumed that both the fill character
and the alignment option are absent.

The meaning of the various alignment options is as follows:
\begin{enumerate}
\item['\texttt{<}'] Forces the field to be left-aligned within the
               available space (This is the default.)
\item['\texttt{>}'] Forces the field to be right-aligned within the
               available space.
\item['\texttt{=}'] Forces the padding to be placed after the sign
               (if any) but before the digits. This is used for
               printing fields in the form '+000000120'. This
               alignment option is only valid for numeric types.
\item['\texttt{\^}'] Forces the field to be centered within the available
                space.
\end{enumerate}

Note that unless a minimum field width is defined, the field width
will always be the same size as the data to fill it, so that the
alignment option has no meaning in this case.

The sign option is only valid for number types, and can be one of
the following:
\begin{enumerate}
\item['\texttt{+}'] Indicates that a sign should be used for both positive
                    as well as negative numbers.
\item['\texttt{-}'] Indicates that a sign should be used only for negative
                    numbers (this is the default behavior).
\item[\textit{space}] Indicates that a leading space should be used on positive
                      numbers, and a minus sign on negative numbers.
\end{enumerate}

The '\verb|#|' option is only valid for integers, and only for binary,
octal, or hexadecimal output. If present, it specifies that the
output will be prefixed by '0b', '0o', or '0x', respectively.  In the
ZanyBlue implementation, the Ada based number notation is used in this
context.

width is a decimal integer defining the minimum field width. If not
specified, then the field width will be determined by the content.

If the width field is preceded by a zero ('\texttt{0}') character, this
enables zero-padding. This is equivalent to an alignment type of
'\texttt{=}' and a fill character of '\texttt{0}'.

The precision is a decimal number indicating how many digits
should be displayed after the decimal point for a floating point
value formatted with '\texttt{f}' and '\texttt{F}', or before and after
the decimal point for a floating point value formatted with '\texttt{g}'
or '\texttt{G}'. For non-number types the field indicates the maximum
field size - in other words, how many characters will be used from the field
content. The precision is not allowed for integer values.

Finally, the type determines how the data should be presented.

The available integer presentation types are:
\begin{enumerate}
\item['\texttt{b}'] Binary format. Outputs the number in base 2.
\item['\texttt{c}'] Character. Converts the integer to the corresponding
                    unicode character before printing.  Not implemented in
                    the ZanyBlue library.
\item['\texttt{d}'] Decimal Integer. Outputs the number in base 10.
\item['\texttt{o}'] Octal format. Outputs the number in base 8.
\item['\texttt{x}'] Hex format. Outputs the number in base 16, using
                    lowercase letters for the digits above 9.
\item['\texttt{X}'] Hex format. Outputs the number in base 16, using
                    uppercase letters for the digits above 9.
\item['\texttt{n}'] Number. This is the same as '\texttt{d}', except that
                    it uses the current locale setting to insert the
                    appropriate number separator characters.  Not implemented
                    in the ZanyBlue library.
\item[\textit{None}] The same as '\texttt{d}'.
\end{enumerate}

The available presentation types for floating point and decimal
values are:
\begin{enumerate}
\item['\texttt{e}']
    Exponent notation. Prints the number in scientific
    notation using the letter 'e' to indicate the
    exponent.
\item['\texttt{E}']
    Exponent notation. Same as 'e' except it uses an upper
    case 'E' as the separator character.
\item['\texttt{f}']
    Fixed point. Displays the number as a fixed-point number.
\item['\texttt{F}']
    Fixed point. Same as 'f'.
\item['\texttt{g}']
    General format. This prints the number as a fixed-point
    number, unless the number is too large, in which case
    it switches to 'e' exponent notation. Infinity and NaN
    values are formatted as inf, -inf and nan, respectively.
\item['\texttt{G}']
    General format. Same as 'g' except switches to 'E'
    if the number gets to large. The representations of
    infinity and NaN are uppercased, too.
\item['\texttt{n}']
    Number. This is the same as 'g', except that it uses the
    current locale setting to insert the appropriate number
    separator characters.
\item['\texttt{\%}']
    Percentage. Multiplies the number by 100 and displays
    in fixed ('f') format, followed by a percent sign. (Not
    implemented).
\item[\textit{None}]
    The same as '\texttt{g}'.
\end{enumerate}

\subsection{ZanyBlue Formatting Implementation}

The ZanyBlue implementation of the formatting follows, in the main,
the Python specification with some deficiencies and some additions
explained later.

The primary formatting method is the \verb|Format| set of functions
which format a message given a facility name, a key within that
facility and a set of arguments (either as an \verb|Argument_List|
or as individual `boxed'' arguments).  The final two arguments for
both this set of \verb|Format| function or the \verb|Print| and
\verb|Print_Line| procedures explained later) is the locale
and the catalog.  All the functions and procedures defined in
this section are defined in the package \verb|ZanyBlue.Text.Formatting|
which is generally the only ZanyBlue package needed by applications.

The locale defaults to the current locale and generally need not be
specified.  A possible example of where a locale would need to be
specified would be a client/server application where the client sends
a locale name defining their preferred locale for messages.

The use of the catalog argument is even rarer and allows messages
to be defined/loaded into separate catalogs.  The ZanyBlue library
maintains a global common catalog which is used as the default for
all functions and procedures that take catalog arguments.

\subsubsection{Format Functions}

The specification of the \verb|Format| function is
\begin{xmpl}
\begin{verbatim}
   function Format (Facility  : Wide_String;
                    Key       : Wide_String;
                    Arguments : Argument_List;
                    Locale    : Locale_Type := Current_Locale;
                    Catalog   : Catalog_Type := Standard_Catalog)
\end{verbatim}
\end{xmpl}
along with the in-line boxed argument version:
\begin{xmpl}
\begin{verbatim}
   function Format (Facility  : Wide_String;
                    Key       : Wide_String;
                    Argument1 : Argument_Type'Class := Null_Argument;
                    Argument2 : Argument_Type'Class := Null_Argument;
                    Argument3 : Argument_Type'Class := Null_Argument;
                    Argument4 : Argument_Type'Class := Null_Argument;
                    Argument5 : Argument_Type'Class := Null_Argument;
                    Locale    : Locale_Type := Current_Locale;
                    Catalog   : Catalog_Type := Standard_Catalog)
      return Wide_String;
\end{verbatim}
\end{xmpl}

\subsubsection{Print Procedures}

Corresponding to the formatting functions, a set of \verb|Print| and
\verb|Print_Line| procedures are available which print to the formatted
message to the standard output file or the given file argument.  These
procedures have versions that take both an argument list, i.e.,
\begin{xmpl}
\begin{verbatim}
   procedure Print (Facility  : Wide_String;
                    Key       : Wide_String;
                    Arguments : Argument_List;
                    Locale    : Locale_Type := Current_Locale;
                    Catalog   : Catalog_Type := Standard_Catalog);
\end{verbatim}
\end{xmpl}
and the in-line ``boxed'' arguments, e.g.,
\begin{xmpl}
\begin{verbatim}
   procedure Print (Facility  : Wide_String;
                    Key       : Wide_String;
                    Argument1 : Argument_Type'Class := Null_Argument;
                    Argument2 : Argument_Type'Class := Null_Argument;
                    Argument3 : Argument_Type'Class := Null_Argument;
                    Argument4 : Argument_Type'Class := Null_Argument;
                    Argument5 : Argument_Type'Class := Null_Argument;
                    Locale    : Locale_Type := Current_Locale;
                    Catalog   : Catalog_Type := Standard_Catalog);
\end{verbatim}
\end{xmpl}
The signature for the \verb|Print_Line| verions are similar.  Both the
\verb|Print| and \verb|Print_Line| procedure sets have corresponding
versions that take a first argument giving the destination file, e.g.,
\begin{xmpl}
\begin{verbatim}
   procedure Print (Destination : Ada.Wide_Text_IO.File_Type;
                    Facility    : Wide_String;
                    Key         : Wide_String;
                    Arguments   : Argument_List;
                    Locale      : Locale_Type := Current_Locale;
                    Catalog     : Catalog_Type := Standard_Catalog);
\end{verbatim}
\end{xmpl}

\subsubsection{Plain Formatting Versions}

Both the \verb|Format| functions and \verb|Print| procedure have versions
that take a message format instead and arguments (either as an argument
list or as in-line ``boxed'' arguments), e.g.,
\begin{xmpl}
\begin{verbatim}
   function Format (Text      : Wide_String;
                    Arguments : Argument_List;
                    Locale    : Locale_Type := Current_Locale)
\end{verbatim}
\end{xmpl}
The locale argument is still required in this context as arguments are
still formatted within the context of a locale.

Usage of these functions and procedures do not externalize the message
text and, as such, do little to help internationalize applications.

\subsubsection{Localized Exceptions}

Ada allows exceptions to be raised with a message string, e.g.,
\begin{xmpl}
\begin{verbatim}
   raise My_Exception with "Something is wrong here";
\end{verbatim}
\end{xmpl}

The ZanyBlue library includes \verb|Raise_Exception| procedures with
signatures paralleling the \verb|Format| methods.  The procedures
raise the identified exception with a localized formatted messages.
Since the Ada standard defines exception message to be a \verb|String|,
the formatted \verb|Wide_String| is converted to a \verb|String| by
UTF-8 encoding the \verb|Wide_String|.  The specification of the 
argument list version of this procedure is
\begin{xmpl}
\begin{verbatim}
   procedure Raise_Exception (E        : Ada.Exceptions.Exception_Id;
                         Facility     : Wide_String;
                         Key          : Wide_String;
                         Arguments    : Argument_List;
                         Locale       : Locale_Type := Current_Locale;
                         Catalog      : Catalog_Type := Standard_Catalog);
\end{verbatim}
\end{xmpl}
The conversion of \verb|Wide_String| to an UTF-8 encoded \verb|String| uses
the GNAT specific Unicode functions.

\subsubsection{Missing Arguments and Exceptions}

Format strings refer to arguments by index, e.g.,
\begin{xmpl}
\begin{verbatim}
    moons=There are {0} moons orbiting "{1}".
\end{verbatim}
\end{xmpl}
expects two ``boxed'' arguments.  If supplied with less than expected, e.g.,
\begin{xmpl}
\begin{verbatim}
    Print_Line ("myapp", "moons", +10);
\end{verbatim}
\end{xmpl}
where the planet name is not supplied, is, by default, considered an error
and the exception \verb|No_Such_Argument_Error| is raised.  This behaviour
can be adjusted by calling the catalogs routine \verb|Disable_Exceptions|.
When exceptions are disabled, missing arguments are replaced in the formatted
string with the format information enclosed in vertical bars rather than
braces.

The \verb|Disable_Exceptions| has an inverse routine \verb|Enable_Exceptions|
which re-enables exceptions.  This is either on the default standard catalog
or a user supplied argument catalog.  The status of exceptions for a catalog
can be queried using the function \verb|Exceptions_Enabled|.

\subsection{Utility Routines}

The \verb|ZanyBlue.Text| root package supplies a number of utility routines
which are generally just wrappers or renamings.  The set of function and
procedures list below.

\subsubsection{Wide\_Hash}

This is an implementation of the standard \verb|String| hash function for
wide strings:
\begin{xmpl}
\begin{verbatim}
   function Wide_Hash (Key : Wide_String) return Ada.Containers.Hash_Type;
\end{verbatim}
\end{xmpl}

\subsubsection{To\_Wide\_String}

This is a simple renaming of the standary library \verb|String| to
\verb|Wide_String| conversion routine:
\begin{xmpl}
\begin{verbatim}
   function To_Wide_String (S : String) return Wide_String
\end{verbatim}
\end{xmpl}

\subsubsection{Wide\_Create}

This routine creates a new file, similar to the standard \verb|Create|
routine.  The contents are expected to be UTF-8 encoded and the name is
converted to UTF-8 before passing to the underlying \verb|Create| routine:
\begin{xmpl}
\begin{verbatim}
   procedure Wide_Create (File : in out Ada.Wide_Text_IO.File_Type;
                          Name : Wide_String);
\end{verbatim}
\end{xmpl}

\subsubsection{Wide\_Open}

Open an existing file using an wide path name (converted to UTF-8) with
UTF-8 encoded contents:
\begin{xmpl}
\begin{verbatim}
   procedure Wide_Open (File : in out Ada.Wide_Text_IO.File_Type;
                        Mode : Ada.Wide_Text_IO.File_Mode;
                        Name : Wide_String);
\end{verbatim}
\end{xmpl}

\subsubsection{To\_UTF8 and From\_UTF8}

The functions \verb|To_UTF8| and \verb|From_UTF8| are utility functions
that simply wrap around the underlying GNAT implementation:
\begin{xmpl}
\begin{verbatim}
   function To_UTF8 (Value : Wide_String) return String;
   function From_UTF8 (Value : String) return Wide_String;
\end{verbatim}
\end{xmpl}

%--------------------------------------------------------------------------
\section{Provided Argument Types}

The formatting is based on ``boxed'' version of data values.  The data
type defined for ``boxing'' correspond to the standard set of Ada types
and are defined in the following sections.

\subsection{Boolean}

The standard formatting for Boolean is not localized.  Values are simply
the Ada defined \verb|Image| function of the \verb|Boolean| type, i.e.,
\verb|TRUE| and \verb|FALSE| since the \verb|Generic_Enumerations| implementation
is used to implement \verb|Boolean|.  E.g.,
\begin{xmpl}
\begin{verbatim}
    Value := True;
    Print_Line ("xmpl", "0001", +Value);
\end{verbatim}
\end{xmpl}

\subsection{Character}

The character implementation simply inserts the character value as is
to the formatted output, e.g.,
\begin{xmpl}
\begin{verbatim}
    Value := 'a';
    Print_Line ("xmpl", "0001", +Value);
\end{verbatim}
\end{xmpl}

\subsection{Duration}

The standard implementation of the duration formatting displays the
hours, minutes and seconds (seconds as a floating point formatted
to three decimal places).  E.g.,
\begin{xmpl}
\begin{verbatim}
    D := End_Time - Start_Time
    Print_Line ("xmpl", "0001", +D);
\end{verbatim}
\end{xmpl}

\subsection{Float}

The \verb|Float| formatting is simply an instanciation of the
\verb|Generic_Floats| package, see this package for information
on the limitation of the current version.

\subsection{Generic\_Enumerations}

The \verb|Generic_Enumerations| package supplies an implementation 
for the Ada defined enumeration types.  The underlying implemenation
uses the \verb|Image| function for the enumeration value and, as a
result, is normally an uppercase value.  The format width and placement
(center, left, right) is repected.

\subsection{Generic\_Fixed}

The \verb|Generic_Fixed| package implemented formatting for the fixed
floating point type.  This is a relatively stub implementation in this
version of the ZanyBlue library and simply dispatches to the underlying
\verb|Ada.Text_IO| routines to format the value.

\subsection{Generic\_Floats}

The \verb|Generic_Floats| package implemented formatting for 
floating point type.  This is a relatively stub implementation in this
version of the ZanyBlue library and simply dispatches to the underlying
\verb|Ada.Text_IO| routines to format the value.

\subsection{Generic\_Integers}

The \verb|Generic_Integers| package implements formatting for integer
types.  The formatting respects the localized zero character which in
this version of ZanyBlue is normally `0' except for the Arabic locale.

\subsection{Generic\_Modulars}

The \verb|Generic_Modulars| package implements formatting for modular
types.  The formatting respects the localized zero character which in
this version of ZanyBlue is normally `0' except for the Arabic locale.

\subsection{Integers}

This is simply an instaniation of the \verb|Generic_Integers| package
for the standard \verb|Integer| type.

\subsection{Strings}

This supports standard ASCII strings.

\subsection{Times}

The implementation for the formatting of times is the more involved
and support two sub-catgories to select either the time or date value
of an \verb|Ada.Calendar.Time| value.  E.g., to format the time component
of a \verb|Time| value use
\begin{xmpl}
\begin{verbatim}
    0001=The time is {0,time}
\end{verbatim}
\end{xmpl}
or to format just the date value,
\begin{xmpl}
\begin{verbatim}
    0001=The date is {0,date}
\end{verbatim}
\end{xmpl}
The date and time formatting is localized using the information from the
CLDR data and include localized day and month names along with localized
date and time formats.

\subsection{Wide\_Characters}

This supports standard wide characters (Unicode).

\subsection{Wide\_Strings}

This supports standard wide string (Unicode).

%--------------------------------------------------------------------------
\section{CLDR Data}

The Unicode.org CLDR data used to define the locale specific information
such as the date and time formats also includes localized names for languages,
scripts and territories.  This localized information is included in the
ZanyBlue Text library via the \verb|ZanyBlue.Text.CLDR| package and can
be used to translate abbreviations, e.g, ``\texttt{en}'' to localized
named, e.g., the function call,
\begin{xmpl}
\begin{verbatim}
   Language_Name ("en")
\end{verbatim}
\end{xmpl}
returns ``English'' in an English locale and ``anglais'' in a French locale.
There localized names for scripts and territories are available via the functions
\verb|Script_Name| and \verb|Territory_Name| functions.

All functions take an optional \verb|Unknown| parameter giving the result
returned for unknown names (defaulting to the empty string) and a final 
locale parameter.

%--------------------------------------------------------------------------
\section{Pseudo Translations}

One of the easiest mistakes to make with an internationalize application is
to include hard-coded strings, i.e., not externalize the message text into
a \texttt{.properties} file.  One technique to detect hard-coded strings
is to generate a pseudo translation in a test locale and test the application.
This requires "translation" of a \texttt{.properties} file into a psuedo
locale (the choice is normally Swahili in Kenya, i.e., \verb|sw_KE|) and
rebuild of a test application with the pseudo translations included.

ZanyBlue adopts a different approach and includes psuedo translation as
part of the library rather than an after the fact exercise.  The pseudo
translation support built into the library support the translation of
messages using simple wide character to wide character replacement, e.g.,
replace all ASCII character with their uppercase equivalents.  Each message
is further highlighted using start and end of message marker characters,
the left and right diamond characters.  Additionally, embedded arguments
are surrounded by French quote characters.

To enable the built-in pseudo translations, the catalogs procedure
\begin{xmpl}
\begin{verbatim}
   procedure Enable_Pseudo_Translations (Catalog : Catalog_Type;
                                         Mapping : Pseudo_Map_Vector);
\end{verbatim}
\end{xmpl}
can be used.  The \verb|Mapping| argument gives the character to character
mapping that should be used in addition to the message and argument marking
of the pseudo translation.

The mappings defined by the ZanyBlue library are:
\begin{enumerate}
\item	\verb|Null_Map| which preserves the message text but includes
	the start and end of messages and arguments.
\item	\verb|Uppercase_Map| in addition to the start and end markers
	for messages and arguments, convert the message text to upper
	case (applies only to ASCII characters).
\item	\verb|Lowercase_Map| in addition to the start and end markers
	for messages and arguments, convert the message text to lower
	case (applies only to ASCII characters).
\item	\verb|Halfwidth_Forms_Map| in addition to the start and end markers
	for messages and arguments, convert the message text to the
	halfwidth forms for Latin alphabetic and numeric characters.
\item	\verb|Enclosed_Alphanumeric_Map| in addition to the start and end
	markers for messages and arguments, convert the message text to the
	enclosed alphanumeric forms for Latin alphabetic characters.
\end{enumerate}

The example applications support pseudo translation via the \verb|-x|
options.

%--------------------------------------------------------------------------
\section{The zbmcompile Utility}

The \verb|zbmcompile| utility compiles \texttt{.properties} files into
an Ada representation allowing easier access to the message text via
lookup in a catalog.

The simplest usage of the utility defines the name of the package to be
created and the facility to be compiled, e.g., for the moons example
application
\begin{xmpl}
\begin{verbatim}
   $ zbmcompile -i -v Moons_Messages moons
   This is ZBMCompile, Version 0.1.0 ALPHA (r1627) at 5:52 PM on 11/19/10
   Copyright (c) 2009-2010, Michael Rohan.  All rights reserved
   Loaded 16 messages for the facility "moons" (4 locales)
   Loaded 1 facilities, 4 keys, 4 locales and 16 messages
   Wrote the spec "Moons_Messages" to the file "moons_messages.ads"
   Wrote the body "Moons_Messages" to the file "moons_messages.adb"
   ZBMCompile completed at 5:52 PM on 11/19/10, elapsed time 0:00:00.263
\end{verbatim}
\end{xmpl}
Here the generated package \verb|Moons_Messages| is compiled from the
\texttt{.properties} files for the \verb|moons| facility in the current
directory.

\subsection{Controlling Status Output}

The \verb|zbmcompile| utility supports options to control the amount
of status information printed:
\begin{itemize}
\item[\texttt{-q}] Reduced the amount of output to just error and warning
                   messages.
\item[\texttt{-v}] Increase the amount of output generated.
\item[\texttt{-D}] Increase the amount of output to aid debugging.
\end{itemize}

\subsection{Definition of Properties Directory}

The default usage assumes the \texttt{.properties} files are located
in the current directory.   To locate the files in another directory,
the \verb|-d| option can be used, e.g.,
\begin{xmpl}
\begin{verbatim}
   $ zbmcompile -i -v -d mesg Moons_Messages moons
\end{verbatim}
\end{xmpl}
would locate the properties associated with the \verb|moons| facility
in the \verb|mesg| directory.

\subsection{Properties File Extension}

The default file extension used when locating properties files is
\texttt{.properties}.  This can be change using the \verb|-e| option.
E.g., to load all \texttt{.msg} files,
\begin{xmpl}
\begin{verbatim}
   $ zbmcompile -i -v -e .msg Moons_Messages moons
\end{verbatim}
\end{xmpl}

\subsection{Auto-Initialization}

The generate Ada code include an initialization routine which loads
the messages into a catalog (defaulting to the standard global
catalog).  The \verb|-i| option includes a call to this initialization
procedure in the body of the generated package.  This allows the
inclusion of the message in an application by simply including the
specification in a compilation unit, normally the main unit.  The
option also causes the inclusion of a warning suppression pragma
in the specification to allow compilation in a strict compilation
environment.

\subsection{Optimization of Messages}

When the \verb|zbmcompile| loads facilities in sequence which, in
general, distributes the messages associated with various locales.
The \verb|zbmcompile| optimize mode performs a second pass on the
loaded messages gathering messages for each locale together.  Since
applications generally don't change locale very often, if at all,
having all the message strings for a locale located in the same
set of pages can improve performance.

For symmetry reasons, the \verb|-g| option is included which
disables optimization.

\subsection{Name of the Generated Files}

The default files generated follow the GNAT naming convention.
This can be changed by explicitly specifying the name of the
specification file via the \verb|-s| option and the body file
via the \verb|-b| option.

\subsection{Locale Selection}

Occasionally, only a subset of the \texttt{.properties} files should
be compiled into the generated Ada package.  This selection is supported
using the \verb|-B|, for base locale, and \verb|-L| options.  E.g., to
generate the Moons message package for just the base, i.e., the properites
file without an include locale and french and german, the command would be
\begin{xmpl}
\begin{verbatim}
   $ zbmcompile -v -B -L fr -L de Moons_Messages moons
\end{verbatim}
\end{xmpl}
These option could be used to generate language packs, possibly via shared
library or dll implementations.

\subsection{Forced Compilation}

When testing using messages from Java projects, the message files will
frequently be found to contain errors from a \verb|zbmcompile| point of
view.  To force the generation of Ada in the context of input errors, the
\verb|-F| can be used.  Note, when used, there is no guarantee the resultant
generated Ada code will compile.

\subsection{Definition of External Initialization Routine}

The possible direction for Ada localization is to allow the loading of
language pack at run-time via shared library or dlls.  This has not been
investigated but in the context of dynamic loading of shared libraries or
dll's, having an initialization name that is well defined makes the
implementation easier.  To support this, the untested functionality of
supplying a linker name for the initialization routine is allowed via the
\verb|-x| option, e.g.,
\begin{xmpl}
\begin{verbatim}
   $ zbmcompile -v -B -x "moons_messages" Moons_Messages moons
\end{verbatim}
\end{xmpl}
